/**
 * @fileoverview Content validator for quiz question generation.
 * This module handles validating and parsing the content generated by Gemini AI.
 */

const logger = require('@utils/logger');
const { logContentToFile } = require('./fileOperations');

/**
 * Extracts JSON content from code blocks in the response
 *
 * @param {string} contentToProcess - The content to extract JSON from
 * @returns {string} The extracted content
 */
function extractJsonFromCodeBlocks(contentToProcess) {
  if (contentToProcess.includes('```')) {
    logger.info('Detected code block in response, attempting to extract JSON content');

    // Try to match JSON code block with language specifier
    let jsonMatch = contentToProcess.match(/```(?:json|javascript|js)\s*([\s\S]*?)\s*```/);

    // If that fails, try to match any code block
    if (!jsonMatch) {
      jsonMatch = contentToProcess.match(/```\s*([\s\S]*?)\s*```/);
    }

    if (jsonMatch && jsonMatch[1]) {
      contentToProcess = jsonMatch[1].trim();
      logger.info('Successfully extracted content from code block');
    } else {
      logger.warn(
        'Failed to extract content from code block using regex, trying alternative approach'
      );

      // Alternative approach: split by ``` and take the middle part if it exists
      const parts = contentToProcess.split('```');
      if (parts.length >= 3) {
        // If we have at least 3 parts, the middle part is our content
        contentToProcess = parts[1].trim();
        // Remove potential language identifier from the first line
        const lines = contentToProcess.split('\n');
        if (
          lines[0] &&
          (lines[0].trim() === 'json' ||
            lines[0].trim() === 'javascript' ||
            lines[0].trim() === 'js')
        ) {
          lines.shift();
        }
        contentToProcess = lines.join('\n').trim();
        logger.info('Extracted content using split method');
      }
    }
  }

  return contentToProcess;
}

/**
 * Extracts array content from a string
 *
 * @param {string} contentToProcess - The content to extract array from
 * @returns {string} The extracted array content
 */
function extractArrayContent(contentToProcess) {
  if (
    !contentToProcess.startsWith('[') &&
    contentToProcess.includes('[') &&
    contentToProcess.includes(']')
  ) {
    logger.info('Content does not start with [, attempting to extract array');
    const arrayStartIndex = contentToProcess.indexOf('[');
    const arrayEndIndex = contentToProcess.lastIndexOf(']') + 1;

    if (arrayStartIndex < arrayEndIndex) {
      contentToProcess = contentToProcess.substring(arrayStartIndex, arrayEndIndex);
      logger.info('Extracted array portion of content');
    }
  }

  return contentToProcess;
}

/**
 * Attempts to find valid JSON by bracket matching
 *
 * @param {string} originalContent - The original content to search in
 * @returns {string} The potential JSON string
 */
function findJsonByBracketMatching(originalContent) {
  let bracketCount = 0;
  let inQuotes = false;
  let escapeNext = false;
  let startPos = -1;
  let endPos = -1;

  for (let i = 0; i < originalContent.length; i++) {
    const char = originalContent[i];

    if (escapeNext) {
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      escapeNext = true;
      continue;
    }

    if (char === '"' && !escapeNext) {
      inQuotes = !inQuotes;
      continue;
    }

    if (inQuotes) continue;

    if (char === '[' || char === '{') {
      if (bracketCount === 0) {
        startPos = i;
      }
      bracketCount++;
    } else if (char === ']' || char === '}') {
      bracketCount--;
      if (bracketCount === 0) {
        endPos = i + 1;
        break;
      }
    }
  }

  if (startPos !== -1 && endPos !== -1) {
    const potentialJson = originalContent.substring(startPos, endPos);
    logger.info('Found potential JSON by bracket matching:', potentialJson.substring(0, 100));
    return potentialJson;
  }

  return null;
}

/**
 * Attempts to parse JSON content
 *
 * @param {string} contentToProcess - The content to parse
 * @param {string} originalContent - The original content for fallback
 * @returns {Object} The parsed content
 * @throws {Error} If parsing fails
 */
function parseJsonContent(contentToProcess, originalContent) {
  try {
    const parsedContent = JSON.parse(contentToProcess);
    logger.info('Successfully parsed JSON content');
    return parsedContent;
  } catch (parseError) {
    logger.error('JSON parsing failed:', parseError.message);
    logger.error('Cleaned content that failed to parse:', contentToProcess);

    // If parsing fails, try one more approach - look for valid JSON by finding matching brackets
    logger.info('Attempting to find valid JSON by bracket matching');

    const potentialJson = findJsonByBracketMatching(originalContent);

    if (potentialJson) {
      try {
        const parsedContent = JSON.parse(potentialJson);
        logger.info('Successfully parsed JSON using bracket matching approach');
        return parsedContent;
      } catch (secondParseError) {
        logger.error('Second parsing attempt failed:', secondParseError.message);
        // Re-throw the original error since both attempts failed
        throw parseError;
      }
    } else {
      // If we couldn't find matching brackets, re-throw the original error
      throw parseError;
    }
  }
}

/**
 * Extracts questions array from parsed content
 *
 * @param {Object} parsedContent - The parsed content
 * @param {boolean} strictMode - Whether to use strict mode
 * @returns {Array} The questions array
 * @throws {Error} If questions cannot be extracted
 */
function extractQuestionsArray(parsedContent, strictMode) {
  if (!Array.isArray(parsedContent)) {
    logger.error('Parsed content is not an array:', typeof parsedContent);

    // If it's an object with a questions property that is an array, use that
    if (
      parsedContent &&
      typeof parsedContent === 'object' &&
      Array.isArray(parsedContent.questions)
    ) {
      logger.info('Found questions array property in parsed content');
      return parsedContent.questions;
    } else if (
      parsedContent &&
      typeof parsedContent === 'object' &&
      parsedContent.question &&
      !strictMode
    ) {
      // If it's a single question object, wrap it in an array (only in non-strict mode)
      logger.info('Found single question object, wrapping in array');
      return [parsedContent];
    } else if (
      parsedContent &&
      typeof parsedContent === 'object' &&
      Array.isArray(parsedContent.items)
    ) {
      // Check if items is an array of objects with question property
      if (
        parsedContent.items.length > 0 &&
        typeof parsedContent.items[0] === 'object' &&
        parsedContent.items[0].question
      ) {
        // Handle case where the AI returns an object with both schema and items array
        logger.info('Found items array property with questions in parsed content');
        return parsedContent.items;
      }
    } else if (
      parsedContent &&
      typeof parsedContent === 'object' &&
      parsedContent.type === 'array' &&
      typeof parsedContent.items === 'object'
    ) {
      // This is likely a schema definition
      logger.info('Found schema definition, looking for actual questions');

      // Look for an array property that might contain the actual questions
      for (const key in parsedContent) {
        if (
          key !== 'type' &&
          Array.isArray(parsedContent[key]) &&
          parsedContent[key].length > 0 &&
          typeof parsedContent[key][0] === 'object' &&
          parsedContent[key][0].question
        ) {
          logger.info(`Found questions in property "${key}"`);
          return parsedContent[key];
        }
      }

      // Special case: if we have both a schema definition and an "items" array with actual questions
      if (
        Array.isArray(parsedContent.items) &&
        parsedContent.items.length > 0 &&
        typeof parsedContent.items[0] === 'object' &&
        parsedContent.items[0].question
      ) {
        logger.info('Found questions in items array (special case)');
        return parsedContent.items;
      }
    }

    throw new Error('Generated content is not an array or valid questions object');
  }

  return parsedContent;
}

/**
 * Validates each question in the array
 *
 * @param {Array} questions - The questions array
 * @param {boolean} strictMode - Whether to use strict mode
 * @returns {Array} The validated questions
 * @throws {Error} If validation fails
 */
function validateQuestions(questions, strictMode) {
  logger.info(`Validating ${questions.length} questions`);

  questions.forEach((question, index) => {
    if (!question.question) {
      throw new Error(`Question ${index + 1} is missing the 'question' field`);
    }

    if (!Array.isArray(question.options)) {
      throw new Error(`Question ${index + 1} has invalid or missing 'options' array`);
    }

    // Ensure we have exactly 4 options
    if (question.options.length !== 4) {
      if (strictMode) {
        throw new Error(`Question ${index + 1} must have exactly 4 options`);
      } else {
        logger.warn(`Question ${index + 1} has ${question.options.length} options instead of 4`);

        // If we have fewer than 4 options, add placeholder options
        while (question.options.length < 4) {
          question.options.push(`Option ${question.options.length + 1} (placeholder)`);
        }

        // If we have more than 4 options, truncate
        if (question.options.length > 4) {
          question.options = question.options.slice(0, 4);
        }
      }
    }

    // Validate correctAnswer is a number between 0-3
    if (
      typeof question.correctAnswer !== 'number' ||
      question.correctAnswer < 0 ||
      question.correctAnswer > 3 ||
      !Number.isInteger(question.correctAnswer)
    ) {
      if (strictMode) {
        throw new Error(`Question ${index + 1} has an invalid 'correctAnswer' (must be 0-3)`);
      } else {
        logger.warn(`Question ${index + 1} has invalid 'correctAnswer': ${question.correctAnswer}`);

        // Try to convert string to number if possible
        if (typeof question.correctAnswer === 'string') {
          const parsed = parseInt(question.correctAnswer, 10);
          if (!isNaN(parsed) && parsed >= 0 && parsed <= 3) {
            question.correctAnswer = parsed;
            logger.info(`Converted string correctAnswer to number: ${parsed}`);
          } else {
            // Default to first option
            question.correctAnswer = 0;
            logger.warn(`Set default correctAnswer to 0 for question ${index + 1}`);
          }
        } else {
          // Default to first option
          question.correctAnswer = 0;
          logger.warn(`Set default correctAnswer to 0 for question ${index + 1}`);
        }
      }
    }

    // Ensure explanation exists
    if (!question.explanation) {
      if (strictMode) {
        throw new Error(`Question ${index + 1} is missing the 'explanation' field`);
      } else {
        logger.warn(`Question ${index + 1} is missing the 'explanation' field`);
        question.explanation = `The correct answer is option ${question.correctAnswer + 1}.`;
      }
    }

    // Validate difficulty
    if (
      !question.difficulty ||
      !['easy', 'medium', 'hard'].includes(question.difficulty.toLowerCase())
    ) {
      if (strictMode) {
        throw new Error(
          `Question ${index + 1} has an invalid 'difficulty' (must be easy, medium, or hard)`
        );
      } else {
        logger.warn(`Question ${index + 1} has invalid 'difficulty': ${question.difficulty}`);
        question.difficulty = 'medium'; // Default to medium
      }
    }

    // Ensure difficulty is lowercase
    question.difficulty = question.difficulty.toLowerCase();

    // Ensure category exists
    if (!question.category) {
      if (strictMode) {
        throw new Error(`Question ${index + 1} is missing the 'category' field`);
      } else {
        logger.warn(`Question ${index + 1} is missing the 'category' field`);
        question.category = 'General';
      }
    }
  });

  logger.info(`Successfully validated ${questions.length} questions`);
  return questions;
}

/**
 * Validates that the generated content is valid JSON and matches the expected schema
 *
 * @param {string} content - The generated content from Gemini AI
 * @param {boolean} [strictMode=false] - If true, throw errors instead of trying to fix issues (used for tests)
 * @returns {Object[]} The parsed questions array
 * @throws {Error} If the content is invalid or doesn't match the schema
 */
function validateGeneratedContent(content, strictMode = false) {
  try {
    if (!content || typeof content !== 'string') {
      throw new Error('Content is empty or not a string');
    }

    // Log the original content for debugging (truncated)
    logger.info('Original content (first 200 chars):', content.substring(0, 200));

    // Log the full content to a separate log file for detailed debugging
    logContentToFile(content);

    // Step 1: Clean the response string to extract JSON
    let contentToProcess = content.trim();
    let originalContent = contentToProcess;

    // Step 2: Handle various markdown code block formats
    contentToProcess = extractJsonFromCodeBlocks(contentToProcess);

    // Step 3: Look for array brackets if we still don't have valid JSON
    contentToProcess = extractArrayContent(contentToProcess);

    // Log the cleaned content
    logger.info('Cleaned content (first 200 chars):', contentToProcess.substring(0, 200));

    // Step 4: Try to parse the content as JSON
    const parsedContent = parseJsonContent(contentToProcess, originalContent);

    // Step 5: Validate that it's an array
    const questionsArray = extractQuestionsArray(parsedContent, strictMode);

    // Step 6: Validate each question has the required fields
    return validateQuestions(questionsArray, strictMode);
  } catch (error) {
    // Log the full error with stack trace
    logger.error('Content validation failed with error:', error);

    // Throw a more descriptive error
    throw new Error(`Invalid generated content: ${error.message}`);
  }
}

module.exports = {
  validateGeneratedContent,
  // Export these for testing or advanced usage
  extractJsonFromCodeBlocks,
  extractArrayContent,
  findJsonByBracketMatching,
  parseJsonContent,
  extractQuestionsArray,
  validateQuestions,
};
